---
title: JavaScript 中的事件循环机制
date: 2021-10-08 22:08:12
tags:
---

JavaScript 是单线程的，一次只能处理一个任务。在正常的环境下这没有什么问题，但是试想一下你正在运行一个需要30秒的任务，在该任务期间我们需要等待30秒才能做其他事情（ JavaScript 默认是浏览器的主线程运行的，所以整个UI都会卡住，无响应）

幸运的是，浏览器为我们提供了一些 JavaScript 引擎本身不提供的功能：Web API。这包括 DOM API、setTimeout、HTTP 请求等。这可以帮助我们创建一些异步的、非阻塞的行为。

当我们调用一个函数时，它会被添加到称为执行栈中。执行栈是 JS 引擎的一部分，这不是特定于浏览器的。它是一个堆栈，意思是先入后出。当一个函数返回一个值时，它会出栈。

![gif](/img/gid1.6.gif)

respond函数返回一个setTimeout函数。在setTimeout由Web API提供给我们：它让我们的任务延迟执行，而不会阻塞主线程。我们传递给setTimeout函数的是一个回调函数，`() => { return 'Hey'}`被添加到 Web API 中。与此同时，setTimeout函数和响应函数从堆栈中弹出，它们都返回了它们的值。

![gif](/img/gif2.1.gif)

在 Web API 中，计时器运行的时间与我们传递给它的第二个参数一样长，即 1000 毫秒。回调不会立即添加到调用堆栈中，而是传递给事件队列。

![gif](/img/gif3.1.gif)

回调函数并不是在 1000 毫秒后被添加到执行栈中（从而返回一个值）。它只是在 1000 毫秒后添加到事件队列中。函数的执行必须排队！这可能是令人疑惑的部分

是时候让事件循环完成它唯一的任务：将事件队列与执行栈连接起来！如果执行栈为空，那么如果所有先前调用的函数都返回了它们的值并出栈，则队事件列中的第一项将添加到执行栈中。在这种情况下，没有调用其他函数，这意味着当回调函数成为队列中的第一项时，执行栈是空的。

![gif](/img/gif4.gif)

回调被添加到执行栈中，被调用，并返回一个值，然后出栈。

![gif](/img/gif5.gif)

执行以下代码，想想整个处理过程是怎样的

```javascript
const foo = () => console.log("First");
const bar = () => setTimeout(() => console.log("Second"), 500);
const baz = () => console.log("Third");

bar();
foo();
baz();
```

让我们快速看看在浏览器中运行这段代码时发生了什么：

![gif](/img/gif14.1.gif)

- 调用bar。 bar返回一个setTimeout函数。
- 我们传递给的回调函数被添加到 Web API、setTimeout函数并bar从执行栈中弹出。
- 计时器运行，同时foo被调用和输出`First`。foo返回（`undefined`），baz被调用，回调函数被添加到事件队列中。
- baz输出`Third`。事件循环在baz返回后看到执行栈为空，之后回调函数被添加到执行栈中。
- 回调函数被执行，输出`Second`。
### 前言
javascript是一门单线程非阻塞的脚本语言，最初的用途是用来和浏览器交互。
单线程意味着javascript运行任何代码的时候，都只有一个主线程来处理任务。javascript的单线程与它的用途有关，javascript的主要用途是与用户互动及操作DOM。这一用途决定了javascript只能是单线程的。如果javascript是多线程的，一个线程在DOM节点上添加内容，另一个线程在DOM上删除内容，这个时候就不能保证浏览器的一致性了。而单线程保证了执行顺序同时也限制了javascript的执行效率，因此有了web worker技术。
而非阻塞是当代码需要执行异步操作的时候（无法立即返回结果，需要花一定的时间才能返回结果，例如I/O事件）的时候，主线程会挂起（pending）这个任务，等待异步任务返回结果后按照一定的规则去执行相应的回调。
既然javascript是单线程的，而且同时又是非阻塞的，javascript是如何做到这一点的？——event loop（事件循环）

### 浏览器中js的事件循环机制

#### 执行栈与事件队列
当javascript运行的时候会将变量存到内存的堆（heap）和栈（stack）中。堆里面存放的是对象，而栈中存放的是基础类型变量及对象指针。
当javascript执行一个方法的时候会生成一个与方法对应的执行上下文（context），这个执行上下文中存放着方法的私有作用域、父级作用域的指向、方法参数，作用域中定义的变量及作用域的this对象。当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。
当一个js第一次执行的时候，js引擎会解析这段代码,并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境.这个过程反复进行，直到执行栈中的代码全部执行完毕。如下图所示
![ab](/img/v2-2f761eb83b50f53d741e6aa1f15a9db1_b.gif)
通过上图可知，一个方法执行会向执行栈中加入这个方法的执行上下文，在这个执行上下文中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行上下文。这个过程可以无限的进行下去。除非发生栈溢出。

以上所说的都是同步代码的执行。那么当异步代码（例如ajax请求）执行的时候会发生什么？，js的另一大特点就是非阻塞，实现这一点的关键在于事件队列（Task Queue）。

js引擎遇到一个异步事件后不会一直等待其返回结果，而是将这个事件挂起，继续处理执行栈中的其它任务。当这个异步事件返回结果后，js会将这个事件加入到当前执行栈不同的另一个队列中（事件队列）。被放入事件队列中的事件不会立即执行回调，而是等待当前执行栈中的所有任务都执行完毕后，主线程处于空闲状态时，主线程会去查找事件队列中是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码。如此反复形成一个循环。这个过程被称为事件循环（Event Loop）
![event loop](/img/v2-da078fa3eadf3db4bf455904ae06f84b_1440w.png)
`图中的stack表示执行栈，web apis则是代表一些异步事件，而callback queue即事件队列`
